/**
  Primer is intended to create the primordial population of Nuclei since I can't think of a good way to make Nucleus do it
  without wasting bits.

  \symbol Pr;
  \symmetries all;
  \author Spencer Harmon;
  \license lgpl;

 */
element Primer : QContent{
  Random r;
  EventWindow ew;
  Cell cell;
  DecisionTree dt;
  DebugUtils du;
  
  typedef Cell.ID ID;
  typedef EventWindow.SiteNum SiteNum;
  typedef Cell.Seqno Seqno;
  typedef DecisionTree.StoredValue StoredValue;
  typedef EventWindow.Symmetry Symmetry;

  //the total number of valid variables, including default variables
  Seqno numTrees;
  //the next non-variable gene number to be created
  Seqno curgene;
  //Whether the next gene created is the first in its tree
  Bool makeTree;
  //the number of genes left to create for this tree
  Seqno treeGenesLeftToCreate;
  //the seqno number of the current tree
  Seqno currentTree;
  //the id of the cell
  ID id;
  //whether the final gene in the last gene has been created
  Bool finished;
  //default number of trees created. Update here when new trees are added.
  constant Unsigned defaultTrees = 4;

  Bool decide(){
    Unsigned(1) odds;
    
    if(r.oneIn(odds.maxof)){
      return true;
    }
    else{
      return false;
    }
  }
  Void nucleus(){
    Atom nu = cell.makeNucleus(id,0,0);
    ew[0] = nu;
  }
  Atom initVars(){
    if(treeGenesLeftToCreate == 0){
      makeTree = true;
      treeGenesLeftToCreate = 1;
      ++currentTree;
    }
    Empty e;
    Atom a = e.atomof;
    if(currentTree <= numTrees){
      a = initTree();
    }
    else{
      finished = true;
    }
    return a;
  }

//todo: seqno can probably be replaced with global curgene/currentTree
//numTrees is already global, and so is ID.
  Atom initTree(){

    Atom a;
    if(makeTree){
      a = initGene(currentTree);
      makeTree = false;
    }else{
      a = initGene(curgene);
      ++curgene;
    }
    --treeGenesLeftToCreate;
    return a;
  }

  Atom initGene(Seqno mySeqno){

    //These nodes and their Stored Values represent the binary tree structure and
    //content of the equation tree

    //this is the return value for initGene
    Unsigned(2) numberOfGenesToAddToMyTree;

    Gene gene;

    gene.seqno = mySeqno;
    gene.id = id;

    //representing addition, subtraction, multiplication, and division
    gene.op = (Unsigned(2)) r.create(3);

    // I Don't like the way this reads, but the idea is
    // that if valTypSwitch is true, it signifies a 
    // stored value (left or right in the binary tree)
    // if of type reference. Here, that means a Seqno of
    // another gene which represents an operator node and a
    // branch of the equation tree. If ValTypSwitch if 
    // false, then the stored value is of type constant, 
    // indicating a terminator in the equation tree and
    // a value in itself to be calculated.
    //
    // Left and right are represented, respectively, by
    // array keys 0 and 1 in the following arrays.
    //
    // The below logic determines the value and type for both
    // sides of the binary tree, represented as eqTree0 and
    // eqTree1 for value and tree0Type and tree1Type for type.
    // Values are of type StoredValue, as defined in DecisionTree.ulam
    // Type can be 0 or 1. Type 0 indicates that the value of eqTreeX
    // is to be interpreted as a literal value (aka terminator), while
    // a value of 1 indicates that the corresponding eqTreeX value 
    // represents the seqno of a gene that is being referenced (aka
    // reference type). A reference could be to another gene within
    // the current tree or to one of the special variables tress.
    //
    // There is a special combination represented by treeXType 1
    // with value 0, that represents a reference to the gene's current
    // comIn value.
    //
    // valTypSwitchX provides a basis on which to make weighted random
    // selections for each possible combinations of type and value.


    Unsigned valTypSwitch0;
    Unsigned valTypSwitch1;
    
    valTypSwitch0 = r.create(100);
    
    valTypSwitch1 = r.create(100);

    //avoid special variables case if there are none
    Unsigned numOfSpecialVars = (Unsigned)(numTrees-defaultTrees);
    if(numOfSpecialVars == 0u){
      if(valTypSwitch0 >=75u){
        valTypSwitch0 -= 25u;
      }
      if(valTypSwitch1 >=75u){
        valTypSwitch1 -= 25u;
      }
    }

    // avoid creating child genes past StoredValue's max
    // this is a local limited address space. Good idea? who knows?
    if(gene.seqno == 63u){
      if(valTypSwitch0 >= 50u && valTypSwitch0 < 75u){
        valTypSwitch0 -= 25u;
      }
      if(valTypSwitch1 >= 50u && valTypSwitch1 < 75u){
        valTypSwitch1 -= 25u;
      }
    }

    //30% chance
    if(valTypSwitch0 >= (Unsigned)0 && valTypSwitch0 < (Unsigned)30){
      //terminator
      gene.tree0Type = 0;

      gene.eqTree0 = (Unsigned(6)) r.create(63);
    }
    //10% chance
    if(valTypSwitch0 >= (Unsigned)30 && valTypSwitch0 < (Unsigned)40){
      //why not some extra chance of nothing? (terminator)
      gene.tree0Type = 0;
      gene.eqTree0 = (StoredValue) 0;
    }
    //10% chance
    if(valTypSwitch0 >= (Unsigned)40 && valTypSwitch0 < (Unsigned)50){
      //comIn 
      //comIn is technically a terminator, but it "feels" like a reference
      //to the equation tree of another Nucleus.
      //Also, type 0 value 0 already has the distinct meaning "the number 0"

      gene.tree0Type = 1;

      // Type 1 value 0 represents comIn. Since seqno starts with 1, this
      // should not conflict with anything
      gene.eqTree0 = (StoredValue)0;
    }
    if(valTypSwitch0 >= (Unsigned)50 && valTypSwitch0 < (Unsigned)75){
      //operator (seqno reference)
      gene.tree0Type = 1;


      if(makeTree){
        //when makeTree is true, the reference needs to be to curgene
        //since numberofgenestoaddtomytree should always be at least one
        //in this stage
        gene.eqTree0 = (StoredValue)(curgene);
      }
      else{        
        gene.eqTree0 = (StoredValue)(curgene+numberOfGenesToAddToMyTree);
      }
      //after creating the reference, record that another gene needs 
      //to be created
      ++numberOfGenesToAddToMyTree;
    }
    if(valTypSwitch0 >= (Unsigned)75 && valTypSwitch0 < (Unsigned)100){
      //special variables, still operator type
      gene.tree0Type = 1;
      
      if(numOfSpecialVars == 1u){
        //can't use r.create on values <= 1.
        gene.eqTree0 = (StoredValue)(numOfSpecialVars + defaultTrees);
      }else{
        gene.eqTree0 = (StoredValue)(r.create((Unsigned)numOfSpecialVars-1u)+1u+defaultTrees);
      }

      //this is a loop; should not happen (but would otherwise)
      if(gene.eqTree0 == gene.seqno){
        gene.tree0Type = 0;
      }
    }
    //30% chance
    if(valTypSwitch1 >= (Unsigned)0 && valTypSwitch1 < (Unsigned)30){
      //terminator
      gene.tree1Type = 0;

      gene.eqTree1 = (Unsigned(6)) r.create(63);
    }
    //10% chance
    if(valTypSwitch1 >= (Unsigned)30 && valTypSwitch1 < (Unsigned)40){
      //why not some extra chance of nothing? (terminator)
      gene.tree1Type = 0;
      gene.eqTree1 = (StoredValue) 0;
    }
    //10% chance
    if(valTypSwitch1 >= (Unsigned)40 && valTypSwitch1 < (Unsigned)50){
      //comIn 
      //comIn is technically a terminator, but it "feels" like a reference
      //to the equation tree of another Nucleus.
      //Also, type 0 value 0 already has the distinct meaning "the number 0"

      gene.tree1Type = 1;

      // Type 1 value 0 represents comIn. Since seqno starts with 1, this
      // should not conflict with anything
      gene.eqTree1 = (StoredValue)0;
    }
    if(valTypSwitch1 >= (Unsigned)50 && valTypSwitch1 < (Unsigned)75){
      //operator (seqno reference)
      gene.tree1Type = 1;

      if(makeTree){
        gene.eqTree1 = (StoredValue)(curgene);
      }
      else{        
        gene.eqTree1 = (StoredValue)(curgene+numberOfGenesToAddToMyTree);
      }
      ++numberOfGenesToAddToMyTree;
    }
    if(valTypSwitch1 >= (Unsigned)75 && valTypSwitch1 < (Unsigned)100){
      //special variables, still operator type
      gene.tree1Type = 1;
      
      if(numOfSpecialVars == 1u){
        //can't use r.create on values <= 1.
        gene.eqTree1 = (StoredValue)(numOfSpecialVars + defaultTrees);
      }else{
        gene.eqTree1 = (StoredValue)(r.create((Unsigned)numOfSpecialVars-1u)+1u+defaultTrees);
      }

      //this is a loop; should not happen (but would otherwise)
      if(gene.eqTree1 == gene.seqno){
        gene.tree1Type = 0;
      }
    }
    
    treeGenesLeftToCreate += numberOfGenesToAddToMyTree;
    du.print(gene.seqno);
    return gene.atomof;
  }

  Void killself(){
    Empty e;
    ew[0] = e;
  }
  Void behave(){
    if(numTrees < 3){
      treeGenesLeftToCreate = 1;
      makeTree = true;
      currentTree = 1;

      // The randomness here is to have common variables accessible to the three
      // main variables.
      // Must have at least three vars (represent symmetry, movement, and comout)
      //

      numTrees = (Seqno)(r.create(3)+3u);

      //because the first seqnos are for variables,
      curgene = (Seqno) (numTrees+1);
    }
    if(id == 0){
      id = cell.genID();
    }
    Atom a = ew[1];
    if(a as Empty){
      ew[1] = initVars();
    }
    if(finished){
      nucleus();
    }
  }
}
