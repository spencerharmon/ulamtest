/**                                      -*- mode:C++ -*- */

/***********************         DO NOT EDIT        ******************************
*
* Gene.h - Element header for ULAM //gcnl:SymbolClass.cpp:750
*
**********************************************************************************
* This code is generated by the ULAM programming language compilation system.
*
* The ULAM programming language compilation system is free software:
* you can redistribute it and/or modify it under the terms of the GNU
* General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option)
* any later version.
*
* The ULAM programming language compilation system is distributed in
* the hope that it will be useful, but WITHOUT ANY WARRANTY; without
* even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE.  See the GNU General Public License for more
* details.
*
* You should have received a copy of the GNU General Public License
* along with the ULAM programming language compilation system
* software.  If not, see <http://www.gnu.org/licenses/>.
*
* @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>
*/

#ifndef UE_102574GENE10_H
#define UE_102574GENE10_H

#include "UlamDefs.h"
#include "Ue_102574Gene10_Types.h"
//Forward Defs of other classes: //gcnl:SymbolTableOfClasses.cpp:576
namespace MFM { template <class EC> struct Uq_10106UrSelf10; }  //FORWARD
namespace MFM { template <class EC> struct Ue_102128EggShell10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_1010919SiteUtils10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10109211EventWindow10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10109211ClusterByID10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10104Cell10; }  //FORWARD
namespace MFM { template <class EC> struct Ue_102717Nucleus10; }  //FORWARD
namespace MFM { template <class EC> struct Ue_10105Empty10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10109210ColorUtils10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_1010919AtomUtils10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10104Fail10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10105MDist10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_102323C2D10; }  //FORWARD
namespace MFM { template <class EC> struct Un_10412489213WindowScanner10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10106Random10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10109210DebugUtils10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10109211SiteVisitor10; }  //FORWARD
namespace MFM { template <class EC> struct Un_102329211OutOfBounds10; }  //FORWARD
namespace MFM { template <class EC> struct Un_10411209215SiteVisitorByID10; }  //FORWARD
namespace MFM { template <class EC> struct Uq_10109212DecisionTree10; }  //FORWARD
namespace MFM { template <class EC> struct Un_1035449217SiteVisitorByType10; }  //FORWARD

namespace MFM{

  template<class EC>
  class Ue_102574Gene10 : public UlamElement<EC> /*, Uq_10106UrSelf10 */  {
    // Extract short names for parameter types
    typedef typename EC::ATOM_CONFIG AC;
    typedef typename AC::ATOM_TYPE T;
    enum { BPA = AC::BITS_PER_ATOM };

    typedef BitVector<BPA> BV; //gcnl:NodeBlockClass.cpp:1621
    typedef BitField<BitVector<BPA>, VD::BITS, T::ATOM_FIRST_STATE_BIT, 0> BFTYP; //gcnl:NodeBlockClass.cpp:1624


  public:

    Ue_102574Gene10(); //gcnl:NodeBlockClass.cpp:1441
    ~Ue_102574Gene10(); //gcnl:NodeBlockClass.cpp:1446

    static Ue_102574Gene10 THE_INSTANCE; //gcnl:NodeBlockClass.cpp:1452

//! Gene.ulam:10: 	AtomUtils au;
    typedef Uq_1010919AtomUtils10<EC> Ut_Um_2au; //offset 0u //gcnl:NodeVarDeclDM.cpp:1065

//! Gene.ulam:11: 	EventWindow ew;
    typedef Uq_10109211EventWindow10<EC> Ut_Um_2ew; //offset 0u //gcnl:NodeVarDeclDM.cpp:1065

//! Gene.ulam:12: 	ClusterByID cl;
    typedef Uq_10109211ClusterByID10<EC> Ut_Um_2cl; //offset 0u //gcnl:NodeVarDeclDM.cpp:1065

//! Gene.ulam:13: 	Cell cell;
    typedef Uq_10104Cell10<EC> Ut_Um_4cell; //offset 0u //gcnl:NodeVarDeclDM.cpp:1065

//! Gene.ulam:14: 	DecisionTree dt;
    typedef Uq_10109212DecisionTree10<EC> Ut_Um_2dt; //offset 0u //gcnl:NodeVarDeclDM.cpp:1065

//! Gene.ulam:15: 	SiteUtils su;
    typedef Uq_1010919SiteUtils10<EC> Ut_Um_2su; //offset 0u //gcnl:NodeVarDeclDM.cpp:1065

//! Gene.ulam:19: 	typedef Unsigned(6) Seqno; //similar to SiteNum, since we don't want to exceed an event window, but has no bearing on position

//! Gene.ulam:21: 	typedef EventWindow.SiteNum SiteNum;

//! Gene.ulam:22: 	typedef AtomUtils.Type ElementType;

//! Gene.ulam:23: 	typedef WindowScanner.Category Category;

//! Gene.ulam:24: 	typedef Cell.ID ID;

//! Gene.ulam:25: 	typedef DecisionTree.StoredValue StoredValue;

//! Gene.ulam:28: 	ID id;
    typedef UlamRefFixed<EC, 0u, 10u> Up_Um_2id; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:29: 	Seqno seqno;
    typedef UlamRefFixed<EC, 10u, 6u> Up_Um_5seqno; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:31: 	Bool canSeeNucleus = true;
    typedef UlamRefFixed<EC, 16u, 1u> Up_Um_9213canSeeNucleus; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:32: 	Unsigned(2) operator;
    typedef UlamRefFixed<EC, 17u, 2u> Up_Um_8operator; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:33: 	Unsigned(2) tree0Type;
    typedef UlamRefFixed<EC, 19u, 2u> Up_Um_919tree0Type; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:34: 	StoredValue eqTree0;
    typedef UlamRefFixed<EC, 21u, 6u> Up_Um_7eqTree0; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:35: 	Unsigned(2) tree1Type;
    typedef UlamRefFixed<EC, 27u, 2u> Up_Um_919tree1Type; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:36: 	StoredValue eqTree1;
    typedef UlamRefFixed<EC, 29u, 6u> Up_Um_7eqTree1; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:37: 	StoredValue value;
    typedef UlamRefFixed<EC, 35u, 6u> Up_Um_5value; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:38: 	StoredValue comIn;
    typedef UlamRefFixed<EC, 41u, 6u> Up_Um_5comIn; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:39: 	StoredValue comOut;
    typedef UlamRefFixed<EC, 47u, 6u> Up_Um_6comOut; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:40: 	Unsigned(3) eventsAlone;
    typedef UlamRefFixed<EC, 53u, 3u> Up_Um_9211eventsAlone; //gcnl:NodeVarDeclDM.cpp:1095

//! Gene.ulam:41: 	Bool reproduced;
    typedef UlamRefFixed<EC, 56u, 1u> Up_Um_9210reproduced; //gcnl:NodeVarDeclDM.cpp:1095

    static void Uf_6behave(const UlamContext<EC>& uc, UlamRef<EC>& ur); //virtual //gcnl:SymbolFunction.cpp:451

    //and its contextual type info for virtual table entries:
    typedef void (* Uf_6behave10) (const UlamContext<EC>&, UlamRef<EC>& ); //gcnl:SymbolFunction.cpp:518
    void Uf_6listen(const UlamContext<EC>& uc, UlamRef<EC>& ur) const; //gcnl:SymbolFunction.cpp:463

    void Uf_5speak(const UlamContext<EC>& uc, UlamRef<EC>& ur) const; //gcnl:SymbolFunction.cpp:463

    void Uf_9212nucleusCheck(const UlamContext<EC>& uc, UlamRef<EC>& ur) const; //gcnl:SymbolFunction.cpp:463

    void Uf_4copy(const UlamContext<EC>& uc, UlamRef<EC>& ur, Ui_Ut_102101u<EC>& Uv_7childID) const; //gcnl:SymbolFunction.cpp:463

    void Uf_9210killCopies(const UlamContext<EC>& uc, UlamRef<EC>& ur) const; //gcnl:SymbolFunction.cpp:463

    //BUILT-IN FUNCTIONS:

    const UlamClassDataMemberInfo & GetDataMemberInfo(u32 dataMemberNumber) const; //gcnl:NodeBlockClass.cpp:2664

    s32 GetDataMemberCount() const; //gcnl:NodeBlockClass.cpp:2728

    const char * GetMangledClassName() const; //gcnl:NodeBlockClass.cpp:2779

    virtual u32 GetClassLength() const; //gcnl:NodeBlockClass.cpp:1992

    virtual const unsigned char * GetString(u32 sidx) const; //gcnl:NodeBlockClass.cpp:2509

    virtual u32 GetStringLength(u32 sidx) const; //gcnl:NodeBlockClass.cpp:2579

    virtual T BuildDefaultAtom() const; //gcnl:NodeBlockClass.cpp:2046

    static VfuncPtr m_vtable[2]; //gcnl:NodeBlockClass.cpp:2287
    virtual VfuncPtr getVTableEntry(u32 idx) const; //gcnl:NodeBlockClass.cpp:2291

    //helper method not called directly
    bool internalCMethodImplementingIs(const UlamClass<EC> * cptrarg) const; //gcnl:NodeBlockClass.cpp:1933

    //helper method not called directly
    bool internalCMethodImplementingIs(const T& targ) const; //gcnl:NodeBlockClass.cpp:2383

    const u32 ReadTypeField(const BV bv); //gcnl:NodeBlockClass.cpp:2416

    void WriteTypeField(BV& bv, const u32 v); //gcnl:NodeBlockClass.cpp:2419

  };

  template<class EC>
  Ue_102574Gene10<EC> Ue_102574Gene10<EC>::THE_INSTANCE;



} //MFM

#include "Ue_102574Gene10.tcc"
#endif //UE_102574GENE10_H
