/**
	\radius 1
	\symmetries all
	\author Spencer Harmon
	\license lgpl
	\color #b52
	\symbol Eg

	form a protective layer over our buried genes in the base layer, then birth them into the event layer.
 */
element EggShell{
	SiteUtils su;
	EventWindow ew;
	DebugUtils du;
	
	ClusterByID cl;

	typedef EventWindow.SiteNum SiteNum;
	typedef Cell.ID ID;

	ID id;
	Bool onCell;
	Bool complete;
	Unsigned(3) wait;
	Unsigned(8) seq;
	Bool incrementedSeq;
	Bool cascading;

	Void createNeighbor(){
		Unsigned radius = ew.getRadius();
		SiteNum slot = cl.emptySlotNearMe();
		EggShell eg;
		eg.id = id;
		if(slot > 0 && slot <= 4){
			ew[slot] = eg;
		}
	}
	Void hatch(){
		createNeighbor();
		Atom a = su.getBase();
		Empty e;
		su.setBase(e);
		ew[0] = a;
	}
	Bool onNucleus(Atom a){
		if(a as Nucleus){
			if(a.id == id){
				return true;
			}else{
				return false;
			}
		}else{
			return false;
		}
	}
	Bool onGene(Atom a){
		if(a as Gene){
			if(a.id == id){
				return true;
			}else{
				return false;
			}
		}else{
			return false;
		}
	}
	Void neighborCheck(){
		Bool dontdie = false;
		Unsigned fam = 0;

		for(SiteNum i = 1; i <= 4; ++i){
			Atom a = ew[i];
			if(a as EggShell){
				if(a.id == id){
					if(a.onCell){
						dontdie = true;
					}
					++fam;
				}
			}
		}
		//all neighbors in moore neighborhood are eggshells with my id.
		if(fam >= 4u){
			complete = true;
		}else {
			complete = false;
		}
		//die if no "oncell" neighbors
		if(!dontdie && !onCell){
			Empty e;
			ew[0] = e;
		}
	}
	Void eggTimer(){
		//Unsigned stor[5];
		for(SiteNum i = 1; i <= 4u; ++i){
			Atom eg = ew[i];
			if(eg as EggShell){
				if(eg.id == id){
					if(eg.seq <= seq){
						eg.seq = (Unsigned(8))(seq + 1);
						ew[i] = eg;
					}else if(eg.seq > seq){
						seq = eg.seq;
					}
				}else{
					complete = false;
				}
			}else{
				complete = false;
			}
		}
		if(seq == seq.maxof){
			cascading = true;
		}
	}
	Void cascade(){
		for(SiteNum i = 1; i <= 4; ++i){
			Atom eg = ew[i];
			if(eg as EggShell){
				if(eg.id == id){
					eg.cascading = true;
					ew[i] = eg;
				}
			}
		}
	}
	Void syncHatch(){
		if(complete){
			eggTimer();
		}
		if(cascading){
			cascade();
			hatch();
		}
	}
	Void behave(){
		Atom a = su.getBase();
		Bool onN = onNucleus(a);
		Bool onG = onGene(a);
		if(onN){
			onCell = true;
			createNeighbor();
			syncHatch();
		}
		if(onG){
			onCell = true;
			createNeighbor();
			syncHatch();
		}
		if(!onN && !onG){
			onCell = false;
			syncHatch();
		}
		neighborCheck();
	}
}
