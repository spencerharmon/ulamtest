ulam 2;
use Cell;
/**
	Nucleus reads Genes to determine its behavior

	\symbol Nu
	\author Spencer Harmon
	\license lgpl
	\symmetries all
	\color #1f0

 */
element Nucleus{
	EventWindow ew;
	Random r;
	Cell cell;
	AtomUtils au;
	SiteUtils su;
	DebugUtils du;
	ClusterByID cl;
	DecisionTree dt;
	
	//typedefs
	typedef ColorUtils.ARGB ARGB;
	typedef Cell.ID ID;
	typedef Cell.Com Com;
	typedef Cell.Seqno Seqno;
	typedef DecisionTree.StoredValue StoredValue;
	typedef EventWindow.SiteNum SiteNum;
	typedef AtomUtils.Type ElementType;
	typedef WindowScanner.Category Category;

	//data members
	ID id; //the all-important cluster id
	ID parent1id;
	ID parent2id;

	//probably should have called this "genecopy" or something
	Bool reproducing;
	Unsigned(7) refractoryPeriod;
	Unsigned(10) lifespan;
	Bool move;
	StoredValue comIn;
	StoredValue comOut;
	ID childID;

	Bool dieOfOldAge(){
		if(lifespan == lifespan.maxof){
			Empty e;
			ew[0] = e;
			return true;
		}
		else{
			return false;
		}
	}
	Bool notIncest(Atom mate){
		if(mate as Nucleus){
			if(parent1id == mate.parent1id || 
			parent1id == mate.parent1id || 
			parent1id == mate.parent2id || 
			parent2id == mate.parent1id || 
			parent2id == mate.parent2id ||
			id == mate.parent1id ||
			id == mate.parent2id ||
			parent1id == mate.id || 
			parent2id == mate.id){
				return false;
			}
		}
		else{
			return true;
		}
		//because g++ gets mad
		return true;
	}
	Void makeChildNucleus(SiteNum slot, Atom mate){
		Nucleus child;
		child.parent1id = id;
		child.id = childID;

		if(mate as Nucleus){
			mate.childID = childID;
			mate.reproducing = true;
			child.parent2id = mate.id;
			ew[slot] = mate;
		}
		su.setBase(child);
	}
	Void reproductionBehavior(){

		if(reproducing){
			layEgg();
		}else{
			childID = cell.genID();
		}
                SiteVisitorByID sv;
                WindowScanner ws;

                ws.resetCategories();
                Category cNucleus = ws.allocateCategory();
                Nucleus aNucleus;
                ElementType tNucleus = au.getValidType(aNucleus);

                sv.setType(cNucleus,tNucleus);
                sv.setID(cNucleus,id);
		sv.neighborCell(cNucleus);

                ws.scan(sv);

                SiteNum slot = ws.getSiteNum(cNucleus);
		if(slot <= 40){
	                Atom mate = ew[slot];
	
			if(mate as Nucleus){
				if(notIncest(mate)){
					if(refractoryPeriod == 0){
						if(!mate.reproducing){
							makeChildNucleus(slot, mate);
						}
						refractoryPeriod = Unsigned(7).maxof;
						reproducing = true;
					}
				}
				if(parent1id == 0 && parent2id == 0){
					if(refractoryPeriod == 0){
						if(!mate.reproducing){
							makeChildNucleus(slot, mate);
						}
						reproducing = true;
						refractoryPeriod = Unsigned(7).maxof;
					}
				}
			}else if(reproducing == false){
				childID = 0;
			}
		}
	}
	Void dontStepOnEggs(){
		Atom a = su.getBase();
		if(a as Nucleus){
			if(a.id == childID){
				move = true;
			}
		}
		if(a as Gene){
			if(a.id == childID){
				move = true;
			}
		}
	}
	Void whetherToMove(){
		if(move = true){
			diffuse();
		}
	}
	Bool onEgg(){
		Atom a = su.getBase();
		if(a as Nucleus){
			if(a.id == childID){
				return true;
			}else{
				return false;
			}
		}else if(a as Gene){
			if(a.id == childID){
				return true;
			}else{
				return false;
			}
		}else{
			return false;
		}
	}
	SiteNum farthestGene(){
		SiteNum ret;
		for(SiteNum i = 41; i > 0; --i){
			Atom a = ew[i];
			if(a as Gene){
				if(a.id == id){
					ret = i;
				}
			}
		}
		return ret;
	}
	Void diffuse(){
		Atom a = ew[1];
		if(onEgg()){
			SiteNum slot = cl.emptySlotNearMe();
			if(slot == 0){
				slot = farthestGene();
			}
			ew.swap(0,slot);
		}else if(a as Empty){
			ew.swap(0,1);
		}else if(a as Gene){
			if (a.id == id){
				ew.swap(0,1);
			}
		}
	}
	//kill self if no genes. 
	Bool geneCheck(){
		for(Seqno i = 1; i <= 40; ++i){
			Atom a = dt.findSeqno(i, id);
			if(a as Gene){
				return true;
			}
		}
		return false;
	}
	Void layEgg(){
		EggShell eg;
		eg.id = childID;
		for(Unsigned i; i < 2u; ++i){
			SiteNum emptySlot = cl.emptySlotNearMe();
			if(emptySlot != 0){
				ew[emptySlot] = eg;
			}
		}
	}
	Void die(){
		Empty e;
		ew[0] = e;
	}
	Void behave(){
//disabling gene check for base layer reproduction test
		if(!geneCheck()){
			die();
		}
		++lifespan;
		--refractoryPeriod;
		//40 was too large. 2 was too small.
		if(refractoryPeriod < refractoryPeriod.maxof/2){
			reproducing = false;
			childID = 0;
		}
		if(!dieOfOldAge()){
			if(reproducing){
				reproductionBehavior();
			}
			cl.bringGenesCloser(id,self);
			dontStepOnEggs();
			Atom movement = dt.findSeqno((Seqno)1, id);
			if(movement as Gene){
				if(movement.value !=0){
					if(r.oneIn((Unsigned)movement.value)){ 
						move = true;
					}
				}
			}else{
				lifespan = (Unsigned(10))(lifespan + 5u);
			}
			Atom com = dt.findSeqno((Seqno)2, id);
			if(com as Gene){
				comOut = com.value;
			}else{
				lifespan = (Unsigned(10))(lifespan + 5u);
			}
			Atom reproduce = dt.findSeqno((Seqno)3, id);
			if(reproduce as Gene){
				if(reproduce.value != 0){
					if(!r.oneIn((Unsigned)reproduce.value)){
						reproductionBehavior();
					}
				}
			}else{
				lifespan = (Unsigned(10))(lifespan + 5u);
			}
			whetherToMove();
		}
	}
}
