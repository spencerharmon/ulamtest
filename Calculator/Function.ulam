/**
	\author Spencer Harmon
	\license lgpl
	\symbol Fn
	\color #82d
	\symmetries all
	
 */
element Function : Agent{

	Int value;
	Bool dieRandomly;

	typedef EventWindow.SiteNum SiteNum;

	Bool checkEvalStatus(){
		return false;
	}
	Bool noCopiesNearMe(){
		for(SiteNum i = 1; i < 41; ++i){
			Atom a = ew[i];
			if(a as Function){
				if(a.child == child && a.parent == parent && a.value == value){
					return false;
				}
			}
		}
		return true;
	}
	Atom me(){
		return self;
	}
	Int typeFunction(Atom a){
		Int ret;
		return ret;
	}
	Int typeFunction(Atom a, Atom b){
		Int notvirtual;
		return notvirtual;
	}
	Atom evaluateParenthesis(ID n, ID a){
		Empty e;
		return e;
	}
	Void overwrite(Int i, ID p, ID c, SiteNum s1){
		Bool virt = false;
	}
	Void expireCopy(){
		//Function atoms cannot expire themselves like most agents when propogating functions to data since they need to preserve the parent and update themselves and the child.
		//i.e. function expire behavior, unlike other agents, necessitates the creation of an additional atom; it must consume a resource.
		//therefore, Function has its own expire behavior, and does not utilize the expire atom except when its child is a closeparenth, when it must expire like a standard agent.
		Function c;
		c.child = child;
		c.parent = parent;
		for(SiteNum i = 1; i < 41; ++i){
			Atom a = ew[i];
			//try to use either copies of ourselves or res
			if(a as Function){
				if(a.parent == parent && a.child == child){
					c.dieRandomly = true;
					ew[i] = c;
				}
			}else if(a as Res){
				//see below
				if(!dieRandomly){
					c.dieRandomly = true;
					ew[i] = c;
				}
			}
		}
		//here, !dieRandomly is a standin for "I'm creating a unique atom and must sacrifice empty space because there's nothing else I can use safely"
		if(!dieRandomly && !c.dieRandomly){
			// otherwise, violate dreg/res and use empty space.
			SiteNum slot = cl.emptySlotNearMe();
			c.dieRandomly = true;
			ew[slot] = c;
		}
	}
	Bool propogateType(SiteNum cSlot){
		Bool collapsed = false;
		SiteNum slot = cl.emptySlotNearMe();
		Atom c = ew[cSlot];
		if(value == 1){
			if(c as Data){
				Add ad;
				ad.parent = parent;
				ad.child = child;

				ad.value = c.value;
				
				Function fn;
				fn.value = value;
				fn.child = c.child;
				fn.parent = c.parent;
				
				collapsed = true;
				expireCopy();
				ew[cSlot] = ad;
				ew[0] = fn;
			}else if(c as CloseParenth){
				CloseParenth cp;
				cp.parent = parent;
				cp.child = c.child;
				ew[cSlot] = cp;

				collapsed = true;
				dieRandomly = true;
			}
		}else if(value == 2){
			if(c as Data){
				Subtract sb;
				sb.parent = parent;
				sb.child = child;

				sb.value = c.value;
				
				Function fn;
				fn.value = value;
				fn.child = c.child;
				fn.parent = c.parent;

				expireCopy();
				ew[cSlot] = sb;
				ew[0] = fn;
			}else if(c as CloseParenth){
				CloseParenth cp;
				cp.parent = parent;
				cp.child = c.child;
				ew[cSlot] = cp;

				collapsed = true;
				dieRandomly = true;
			}
		}else if(value == 3){
			if(c as Data){
				Divide dv;
				dv.parent = parent;
				dv.child = child;

				dv.value = c.value;
				
				Function fn;
				fn.value = value;
				fn.child = c.child;
				fn.parent = c.parent;

				expireCopy();
				ew[0] = fn;
				ew[cSlot] = dv;
			}else if(c as CloseParenth){
				CloseParenth cp;
				cp.parent = parent;
				cp.child = c.child;

				collapsed = true;
				ew[cSlot] = cp;
				dieRandomly = true;
			}
		}
		return collapsed;
	}
	Void behave(){
		if(dieRandomly){
			expireCopy();
			if(r.oneIn(100)){
				die();
			}
		}else{
			SiteNum cSlot = findChild();
			if(cSlot > 0){
				if(!propogateType(cSlot)){
					clusterDiffuse();
				}
			}else{
				clusterDiffuse();
			}
		}
	}
}
