quark Agent{
	EventWindow ew;
	AtomUtils au;
	Random r;
	Cluster cl;
	DebugUtils du;
	DregResUtils dru;

	typedef Unsigned(16) ID;
	typedef EventWindow.SiteNum SiteNum;
	typedef AtomUtils.Type Type;
	
	ID parent;
	ID child;

	Void clusterDiffuse(){
		SiteNum sChild;
		SiteNum sParent;
		Unsigned familySeen = 0;
		for(SiteNum i = 1; i<41; ++i){
			Atom a = ew[i];
			if(a as Agent){
				if(a.child == parent){
					SiteNum slot = cl.emptySlotNearMe();
					ew.swap(i,slot);
					++familySeen;
				}
				if(a.parent == child){
					SiteNum slot = cl.emptySlotNearMe();
					ew.swap(i,slot);
					++familySeen;
				}
			}
		}
		if(numCopiesNearMe() < 2u){
			copySelf();
			agentCluster();
		}else if(lowrescount()){
			die();
		}else agentCluster();
	}
	Bool lowrescount(){
		Unsigned rescount;
		for(SiteNum i = 1; i < 41; ++i){
			Atom a = ew[i];
			if(a as Res){
				++rescount;
			}
		}
		if(rescount < 7u){
			return true;
		}else return false;
	}
	virtual Unsigned numCopiesNearMe();
	virtual Atom me();
	Void copySelf(){
			SiteNum slot = dru.resSlotNearMe();
			Atom a = me();
			if(slot > 0){
				ew[slot] = a;
			}else{ die(); }
	}
	Void agentCluster(){
		for(SiteNum i = 1; i < 41; ++i){
			Atom a = ew[i];
			if(a as Agent){
				SiteNum slot = cl.emptySlotNearMe();
				if(r.oneIn(10)){
					ew.swap(slot,i);
				}
			}
		}
	}
	Void diffuse(){
		SiteNum slot = cl.emptySlotNearMe();
		ew.swap(0,slot);
	}
	SiteNum findChild(){
		for(SiteNum i = 1; i <41; ++i){
			Atom a = ew[i];
			if(a as Agent){
				if(a.parent == child){
					return i;
				}
			}
		}
		return 0;
	}
	SiteNum findParent(){
		for(SiteNum i = 1; i <41; ++i){
			Atom a = ew[i];
			if(a as Agent){
				if(a.child == parent){
					return i;
				}
			}
		}
		return 0;
	}
	virtual Int typeFunction(Atom a);
	virtual Void overwrite(Int val, ID p, ID c, SiteNum slot);

	//would prefer if this was a class function, but evaluateparenthesis needs to know the value of the agent, and that's not a class member since quarks can only hold 32 bits
	//question: why this limitation on quarks?
	virtual Atom evaluateParenthesis(ID c, ID p);

	Void operateOnChild(Atom c,SiteNum cSlot){
		Int val = typeFunction(c);
		if(c as Agent){
			overwrite(val,parent,c.child,cSlot);
		}
	}

	Atom expire(){
		Expire e;
		e.parent = parent;
		e.child = child;
		return e;
	}
	virtual Bool checkEvalStatus();
	virtual Bool collapse(SiteNum cSlot, SiteNum pSlot){
		Atom p = ew[pSlot];
		Atom c = ew[cSlot];
		Bool collapsed = false;
		Int val; 
		if(cSlot > 0){
			if(pSlot > 0){
				//can see both
				if(p as OpenParenth){
					if(c as CloseParenth){
						if(checkEvalStatus()){
							Atom a = evaluateParenthesis(p.child,p.parent);
							ew[pSlot] = a;
							
							CloseParenth cp;
							cp.child = c.child;
							cp.parent = parent;
							ew[cSlot] = cp;
	
							collapsed = true;
							Atom e = expire();
							ew[0] = e;
						}
					}else{
						//don't operate on openparenth
						if(c as OpenParenth){
							//no nothing
						}else if(c as CloseParenth){

						}else{
							operateOnChild(c,cSlot);

							collapsed = true;
							Atom e = expire();
							ew[0] = e;
						}

					}
				}
			}
		}
		return collapsed;
	}
	Atom changeType(Atom a, Int val, ID p, ID c){
		Atom n;
		n = au.new(au.getType(a));
		if(n as OpenParenth){
			n.value = val;
			n.parent = p;
			n.child = c;
			return n;
		}else if(n as CloseParenth){
			n.parent = p;
			n.child = c;
			return n;
		}else if(n as Add){
			n.value = val;
			n.parent = p;
			n.child = c;
			return n;
		}else if(n as Subtract){
			n.value = val;
			n.parent = p;
			n.child = c;
			return n;
		}else if(n as Divide){
			n.value = val;
			n.parent = p;
			n.child = c;
			return n;
		}else{
			Atom a;
			return a;
		}
	}
	Void die(){
		Res r;
		ew[0] = r;
	}
}
